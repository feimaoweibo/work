import threading
import time
# 可重入锁 threading.Rlock()
'''
为了支持在同一线程中多次请求同一资源，python提供了“可重入锁”：threading.RLock.
RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资
源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资
源。这里以例1为例，如果使用RLock代替Lock，则不会发生死锁
'''
class MyThread(threading.Thread):
    def run(self):
        global num
        time.sleep(1)
        if mutex.acquire(1):
            num = num+1
            msg = self.name + "set num to " + str(num)
            print(msg)
            mutex.acquire()
            mutex.release()
            mutex.release()
num = 0
mutex = threading.RLock()
def testTh():
    for i in range(5):
        t = MyThread()
        t.start()
if __name__ == "__main__":
    testTh()